{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","../../../projects/ng-devtools-backend/src/lib/utils.ts","../../../projects/ng-devtools-backend/src/lib/highlighter.ts","../../../projects/ng-devtools-backend/src/lib/version.ts","../../../projects/ng-devtools-backend/src/lib/lview-transform.ts","../../../projects/ng-devtools-backend/src/lib/state-serializer/serialized-descriptor-factory.ts","../../../projects/ng-devtools-backend/src/lib/state-serializer/state-serializer.ts","../../../projects/ng-devtools-backend/src/lib/component-tree.ts","../../../projects/ng-devtools-backend/src/lib/router-tree.ts","../../../projects/ng-devtools-backend/src/lib/hooks/identity-tracker.ts","../../../projects/ng-devtools-backend/src/lib/hooks/index.ts","../../../projects/ng-devtools-backend/src/lib/hooks/capture.ts","../../../projects/ng-devtools-backend/src/lib/hooks/hooks.ts","../../../projects/ng-devtools-backend/src/lib/component-inspector/component-inspector.ts","../../../projects/ng-devtools-backend/src/lib/set-console-reference.ts","../../../projects/ng-devtools-backend/src/lib/angular-check.ts","../../../projects/ng-devtools-backend/src/lib/client-event-subscribers.ts","../../../projects/ng-devtools-backend/src/lib/index.ts"],"names":["Object","create","__values","o","s","Symbol","iterator","m","i","call","length","next","value","done","TypeError","__read","n","r","e","ar","push","error","overlay","overlayContent","runOutsideAngular","f","w","window","Zone","current","_name","_parent","run","componentMetadata","instance","constructor","ɵcmp","isCustomElement","node","customElements","HTMLElement","tagName","toLowerCase","get","findComponentAndHost","el","component","host","ng","getComponent","parentElement","getDirectiveName","dir","name","highlight","cmp","rect","doc","ownerDocument","documentElement","parent","parentNode","nodeType","contains","inDoc","getBoundingClientRect","getComponentRect","document","createElement","style","backgroundColor","position","zIndex","pointerEvents","display","borderRadius","setAttribute","bottom","right","fontFamily","fontSize","padding","color","appendChild","content","pre","opacity","innerText","text","createTextNode","post","_a","_b","width","_c","height","_d","top","_e","left","innerHTML","forEach","child","body","showOverlay","unHighlight","removeChild","versionElement","querySelector","defaultVersion","version","_c$1","_b$1","_a$1","getAttribute","match","VERSION","HEADER_OFFSET","latest","SemVerDSL","gte","eq","METADATA_PROPERTY_NAME","getLViewFromDirectiveOrElementInstance","context","Array","isArray","lView","getDirectiveHostElement","ctx","components","getNode","data","idx","directives","tNode","elementName","nodeName","directiveStart","directiveEnd","dirMeta","template","isElement","element","nativeElement","children","extractNodes","lViewOrLContainer","nodes","tView","Node","buildDirectiveTree","serializable","PropType","Boolean","String","Null","Number","Undefined","Unknown","BigInt","Function","HTMLNode","Date","typeToDescriptorPreview","prop","truncate","toString","_","parseInt","keys","ignoreList","Set","shallowPropTypeToTreeMetaData","editable","expandable","createShallowSerializedDescriptor","propData","type","shallowSerializedDescriptor","preview","undefined","getNestedDescriptorValue","levelOptions","nestedSerializer","currentLevel","map","nestedProp","reduce","accumulator","hasOwnProperty","has","getLevelDescriptorValue","continuation","level","nested","propName","str","max","substr","commonTypes","boolean","bigint","function","number","string","symbol","getPropType","prototype","serializableInstance","levelSerializer","nestedSerializerContinuation","nestedSerializedDescriptor","createNestedSerializedDescriptor","nestedLevel","findIndex","v","levelSerializedDescriptor","createLevelSerializedDescriptor","serializeDirectiveState","levels","result","deeplySerializeSelectedProperties","props","getLatestComponentState","query","directiveForest","buildDirectiveForest","queryDirectiveForest","selectedElement","populateResultSet","propertyQuery","PropertyQueryTypes","All","metadata","getDirectiveMetadata","Specified","properties","safelyGrabMetadata","key","ɵdir","console","warn","inputs","outputs","encapsulation","onPush","getRootLViewsHelper","rootLViews","add","roots","querySelectorAll","from","getRootLViews","concat","apply","to","il","j","__spreadArray","forest","position_1","position_1_1","updateState","updatedStateData","ngd","directiveId","directive","mutateComponentOrDirective","applyChanges","getOwningComponent","comp","compOrDirective","valueKey","keyPath","pop","parentObjectOfValueToUpdate","newValue","parseRoutes","router","rootName","rootComponentType","rootChildren","config","handler","path","assignChildrenToParent","isAux","specificity","hash","parentPath","childName","loadChildren","redirectTo","childRouteName","childDescendents","_loadedConfig","routes","isAuxRoute","outlet","pathFragment","routeConfig","split","join","directiveForestHooks","eventMap","IdentityTracker","this","_directiveIdCounter","_currentDirectivePosition","Map","_currentDirectiveId","_isComponent","getDirectivePosition","getDirectiveId","hasDirective","index","_this","indexedForest","indexForest","newNodes","removedNodes","allNodes","root","_index","isComponent","set","_indexNode","destroy","indexTree","parentPosition","d","assign","hookNames","hookMethodNames","hook","hookTViewProperties","getLifeCycleName","obj","fn","proto","getPrototypeOf","getOwnPropertyNames","keys_1","keys_1_1","fnName","hookNames_1","hookNames_1_1","hookName","indexOf","DirectiveForestHooks","_patched","_undoLifecyclePatch","_lastChangeDetection","_tracker","_forest","_indexedForest","_inChangeDetection","_changeDetection$","Subject","_hooks","defineProperty","getIndexedDirectiveForest","getDirectiveForest","initialize","meta","p","_observeLifecycle","_observeComponent","_fireCreationCallback","delete","_fireDestroyCallback","subscribe","unsubscribe","splice","id","_onCreate","_onDestroy","declarations","original","self","patched","Promise","resolve","then","start","performance","now","_onChangeDetectionStart","arguments","_onChangeDetectionEnd","tview","self_1","lifecycleHookName","_onLifecycleHookStart","_onLifecycleHookEnd","__","___","_invokeCallback","____","args","cb","markName","method","supportsPerformance","globalThis","getEntriesByName","recordMark","mark","endMark","end","measure","clearMarks","clearMeasures","timingAPIFlag","enableTimingAPI","disableTimingAPI","timingAPIEnabled","initializeOrGetDirectiveForestHooks","onChangeDetectionStart","onChangeDetectionEnd","onLifecycleHookStart","lifecyle","onLifecycleHookEnd","inProgress","inChangeDetection","frameDuration","hooks","stop","flushBuffer","startEvent","label","getEventStart","getHooks","onFrame","timeStartMap","onCreate","lifecycle","source_1","getChangeDetectionSource","changeDetection","profile","startTimestamp","duration","onDestroy","insertElementProfile","frames","pos","lastIdx","lastFrame","exists","insertOrMerge","source","items","positions","positionDirective","sort","lexicographicOrder","frame","traverse","prepareInitialFrame","zone","currentTask","a","b","ComponentInspector","componentOptions","onComponentEnter","onComponentLeave","onComponentSelect","bindMethods","_onComponentEnter","_onComponentSelect","_onComponentLeave","startInspecting","addEventListener","elementMouseOver","elementClick","cancelEvent","stopInspecting","removeEventListener","stopImmediatePropagation","preventDefault","_selectedComponent","target","bind","highlightByPosition","elementToHighlight","foundComponent","findNodeInForest","nodesForConsoleReference","_setConsoleReference","referenceNode","prepareCurrentReferencesForInsertion","unshift","assignConsoleReferencesFrom","foundIndex","nodeToLookFor","arrayEquals","referenceNodes","setDirectiveKey","getConsoleReferenceWithIndexOf","configurable","consoleReferenceIndex","appIsAngularInDevMode","appIsAngular","appHasGlobalNgDebugObject","appIsAngularIvy","getAllAngularRootElements","__ngContext__","getAngularVersion","subscribeToClientEvents","messageBus","on","shutdownCallback","getLatestComponentExplorerViewCallback","checkForAngularCallback","startProfilingCallback","stopProfilingCallback","selectedComponentCallback","getNestedPropertiesCallback","getRoutesCallback","major","appIsSupportedAngularVersion","setupInspector","changeDetection$","pipe","debounceTime","emit","prepareForestForSerialization","checkForAngular","getRoutes","Error","startProfiling","stopProfiling","propPath","emitEmpty","propPath_1","propPath_1_1","ngVersion","appIsIvy","devMode","ivy","setTimeout","inspector","serializedPosition"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","export const runOutsideAngular = (f: () => any): void => {\n  const w = window as any;\n  if (!w.Zone || !w.Zone.current) {\n    f();\n    return;\n  }\n  if (w.Zone.current._name !== 'angular') {\n    w.Zone.current.run(f);\n    return;\n  }\n  w.Zone.current._parent.run(f);\n};\n\nexport const componentMetadata = (instance: any) => instance.constructor.ɵcmp;\n\nexport const isCustomElement = (node: Node) => {\n  if (typeof customElements === 'undefined') {\n    return false;\n  }\n  if (!(node instanceof HTMLElement)) {\n    return false;\n  }\n  const tagName = node.tagName.toLowerCase();\n  return !!customElements.get(tagName);\n};\n","import { Type } from '@angular/core';\n\nlet overlay: any;\nlet overlayContent: any;\n\ndeclare const ng: any;\n\nexport const DEV_TOOLS_HIGHLIGHT_NODE_ID = '____ngDevToolsHighlight';\n\nfunction init(): void {\n  if (overlay) {\n    return;\n  }\n  overlay = document.createElement('div');\n  overlay.style.backgroundColor = 'rgba(104, 182, 255, 0.35)';\n  overlay.style.position = 'fixed';\n  overlay.style.zIndex = '2147483647';\n  overlay.style.pointerEvents = 'none';\n  overlay.style.display = 'flex';\n  overlay.style.borderRadius = '3px';\n  overlay.setAttribute('id', DEV_TOOLS_HIGHLIGHT_NODE_ID);\n  overlayContent = document.createElement('div');\n  overlayContent.style.backgroundColor = 'rgba(104, 182, 255, 0.9)';\n  overlayContent.style.position = 'absolute';\n  overlayContent.style.bottom = '-23px';\n  overlayContent.style.right = '0px';\n  overlayContent.style.fontFamily = 'monospace';\n  overlayContent.style.fontSize = '11px';\n  overlayContent.style.padding = '2px 3px';\n  overlayContent.style.borderRadius = '3px';\n  overlayContent.style.color = 'white';\n  overlay.appendChild(overlayContent);\n}\n\nexport const findComponentAndHost = (el: Node | undefined): { component: any; host: HTMLElement | null } => {\n  if (!el) {\n    return { component: null, host: null };\n  }\n  while (el) {\n    const component = el instanceof HTMLElement && ng.getComponent(el);\n    if (component) {\n      return { component, host: el as HTMLElement };\n    }\n    if (!el.parentElement) {\n      break;\n    }\n    el = el.parentElement;\n  }\n  return { component: null, host: null };\n};\n\n// Todo(aleksanderbodurri): this should not be part of the highlighter, move this somewhere else\nexport const getDirectiveName = (dir: Type<unknown> | undefined | null): string => {\n  if (dir) {\n    return dir.constructor.name;\n  }\n  return 'unknown';\n};\n\nexport const highlight = (el: HTMLElement): void => {\n  const cmp = findComponentAndHost(el).component;\n  const rect = getComponentRect(el);\n\n  init();\n  if (rect) {\n    const content: Node[] = [];\n    const name = getDirectiveName(cmp);\n    if (name) {\n      const pre = document.createElement('span');\n      pre.style.opacity = '0.6';\n      pre.innerText = '<';\n      const text = document.createTextNode(name);\n      const post = document.createElement('span');\n      post.style.opacity = '0.6';\n      post.innerText = '>';\n      content.push(pre, text, post);\n    }\n    showOverlay(rect, content);\n  }\n};\n\nexport function unHighlight(): void {\n  if (overlay && overlay.parentNode) {\n    document.body.removeChild(overlay);\n  }\n}\n\nexport function inDoc(node: any): boolean {\n  if (!node) {\n    return false;\n  }\n  const doc = node.ownerDocument.documentElement;\n  const parent = node.parentNode;\n  return doc === node || doc === parent || !!(parent && parent.nodeType === 1 && doc.contains(parent));\n}\n\nexport function getComponentRect(el: Node): DOMRect | ClientRect | undefined {\n  if (!(el instanceof HTMLElement)) {\n    return;\n  }\n  if (!inDoc(el)) {\n    return;\n  }\n  return el.getBoundingClientRect();\n}\n\ninterface OverlayDimensionsAndPosition {\n  width: number;\n  height: number;\n  top: number;\n  left: number;\n}\n\nfunction showOverlay(\n  { width = 0, height = 0, top = 0, left = 0 }: OverlayDimensionsAndPosition,\n  content: any[] = []\n): void {\n  overlay.style.width = ~~width + 'px';\n  overlay.style.height = ~~height + 'px';\n  overlay.style.top = ~~top + 'px';\n  overlay.style.left = ~~left + 'px';\n\n  overlayContent.innerHTML = '';\n  content.forEach((child) => overlayContent.appendChild(child));\n\n  document.body.appendChild(overlay);\n}\n","const versionElement = document.querySelector('[ng-version]');\nconst versionRe = /(\\d+\\.\\d+\\.\\d+(-(next|rc)\\.\\d+)?)/;\n\nconst defaultVersion = '0.0.0';\nlet version = defaultVersion;\nif (versionElement) {\n  version = versionElement.getAttribute('ng-version') ?? defaultVersion;\n  version = (version.match(versionRe) ?? [''])[0] ?? defaultVersion;\n}\n\nexport const VERSION = version;\n","import { ComponentTreeNode, ComponentInstanceType, DirectiveInstanceType } from './component-tree';\nimport { isCustomElement } from './utils';\nimport { getDirectiveName } from './highlighter';\nimport { SemVerDSL } from 'semver-dsl';\nimport { VERSION } from './version';\n\nlet HEADER_OFFSET = 19;\n\nconst latest = () => {\n  HEADER_OFFSET = 20;\n};\n\nSemVerDSL(VERSION).gte('10.0.0-next.4', latest);\n\n// In g3 everyone has version 0.0.0, using HEAD from master.\nSemVerDSL(VERSION).eq('0.0.0', latest);\n\nconst TYPE = 1;\nconst ELEMENT = 0;\nconst LVIEW_TVIEW = 1;\nexport const METADATA_PROPERTY_NAME = '__ngContext__';\n\nconst isLContainer = (value: any): boolean => {\n  return Array.isArray(value) && value[TYPE] === true;\n};\n\nconst isLView = (value: any): boolean => {\n  return Array.isArray(value) && typeof value[TYPE] === 'object';\n};\n\nexport const getLViewFromDirectiveOrElementInstance = (dir: any): null | {} => {\n  if (!dir) {\n    return null;\n  }\n  const context = dir[METADATA_PROPERTY_NAME];\n  if (!context) {\n    return null;\n  }\n  if (isLView(context)) {\n    return context;\n  }\n  return context.lView;\n};\n\nexport const getDirectiveHostElement = (dir: any) => {\n  const ctx = dir[METADATA_PROPERTY_NAME];\n  if (ctx[0] !== null) {\n    return ctx[0];\n  }\n  const components = ctx[LVIEW_TVIEW].components;\n  if (!components || components.length !== 1) {\n    return false;\n  }\n  return ctx[components[0]][0];\n};\n\nconst getNode = (lView: any, data: any, idx: number): ComponentTreeNode => {\n  const directives: DirectiveInstanceType[] = [];\n  let component: ComponentInstanceType | null = null;\n  const tNode = data[idx];\n  const node = lView[idx][ELEMENT];\n  const elementName = (node.tagName || node.nodeName).toLowerCase();\n  for (let i = tNode.directiveStart; i < tNode.directiveEnd; i++) {\n    const dir = lView[i];\n    const dirMeta = data[i];\n    if (dirMeta && dirMeta.template) {\n      component = {\n        name: elementName,\n        instance: dir,\n        isElement: isCustomElement(node),\n      };\n    } else if (dirMeta) {\n      directives.push({\n        name: getDirectiveName(dir),\n        instance: dir,\n      });\n    }\n  }\n  return {\n    element: elementName,\n    nativeElement: lView[idx][ELEMENT],\n    directives,\n    component,\n    children: [],\n  };\n};\n\nconst extractNodes = (lViewOrLContainer: any, nodes: ComponentTreeNode[] = []): ComponentTreeNode[] => {\n  if (isLContainer(lViewOrLContainer)) {\n    for (let i = 9; i < lViewOrLContainer.length; i++) {\n      if (lViewOrLContainer[i]) {\n        extractNodes(lViewOrLContainer[i], nodes);\n      }\n    }\n    return nodes;\n  }\n  const lView = lViewOrLContainer;\n  const tView = lView[LVIEW_TVIEW];\n  for (let i = HEADER_OFFSET; i < lView.length; i++) {\n    if (lView[i] && tView.data && lView[i][ELEMENT] instanceof Node) {\n      const node = getNode(lView, tView.data, i);\n\n      // TODO(mgechev): verify if this won't make us skip projected content.\n      if (node.component || node.directives.length) {\n        nodes.push(node);\n        extractNodes(lView[i], node.children);\n      }\n    }\n  }\n  return nodes;\n};\n\nexport const buildDirectiveTree = (lView: any) => extractNodes(lView);\n","import { Descriptor, NestedProp, PropType } from 'protocol';\nimport { METADATA_PROPERTY_NAME } from '../lview-transform';\n\nexport interface CompositeType {\n  type: Extract<PropType, PropType.Array | PropType.Object>;\n  prop: any;\n}\n\nexport interface TerminalType {\n  type: Exclude<PropType, PropType.Array | PropType.Object>;\n  prop: any;\n}\n\nexport type PropertyData = TerminalType | CompositeType;\n\nexport type Formatter<Result> = {\n  [key in PropType]: (data: any) => Result;\n};\n\ninterface LevelOptions {\n  currentLevel: number;\n  level?: number;\n}\n\nconst serializable: { [key in PropType]: boolean } = {\n  [PropType.Boolean]: true,\n  [PropType.String]: true,\n  [PropType.Null]: true,\n  [PropType.Number]: true,\n  [PropType.Object]: true,\n  [PropType.Undefined]: true,\n  [PropType.Unknown]: true,\n  [PropType.Array]: false,\n  [PropType.BigInt]: false,\n  [PropType.Function]: false,\n  [PropType.HTMLNode]: false,\n  [PropType.Symbol]: false,\n  [PropType.Date]: false,\n};\n\nconst typeToDescriptorPreview: Formatter<string> = {\n  [PropType.Array]: (prop: any) => `Array(${prop.length})`,\n  [PropType.BigInt]: (prop: any) => truncate(prop.toString()),\n  [PropType.Boolean]: (prop: any) => truncate(prop.toString()),\n  [PropType.String]: (prop: any) => `\"${prop}\"`,\n  [PropType.Function]: (prop: any) => `${prop.name}(...)`,\n  [PropType.HTMLNode]: (prop: any) => prop.constructor.name,\n  [PropType.Null]: (_: any) => 'null',\n  [PropType.Number]: (prop: any) => parseInt(prop, 10).toString(),\n  [PropType.Object]: (prop: any) => (Object.keys(prop).length > 0 ? '{...}' : '{}'),\n  [PropType.Symbol]: (_: any) => 'Symbol()',\n  [PropType.Undefined]: (_: any) => 'undefined',\n  [PropType.Date]: (_: any) => 'Date()',\n  [PropType.Unknown]: (_: any) => 'unknown',\n};\n\nconst ignoreList = new Set([METADATA_PROPERTY_NAME, '__ngSimpleChanges__']);\n\nconst shallowPropTypeToTreeMetaData = {\n  [PropType.String]: {\n    editable: true,\n    expandable: false,\n  },\n  [PropType.BigInt]: {\n    editable: false,\n    expandable: false,\n  },\n  [PropType.Boolean]: {\n    editable: true,\n    expandable: false,\n  },\n  [PropType.Number]: {\n    editable: true,\n    expandable: false,\n  },\n  [PropType.Date]: {\n    editable: true,\n    expandable: false,\n  },\n  [PropType.Null]: {\n    editable: true,\n    expandable: false,\n  },\n  [PropType.Undefined]: {\n    editable: true,\n    expandable: false,\n  },\n  [PropType.Symbol]: {\n    editable: false,\n    expandable: false,\n  },\n  [PropType.Function]: {\n    editable: false,\n    expandable: false,\n  },\n  [PropType.HTMLNode]: {\n    editable: false,\n    expandable: false,\n  },\n  [PropType.Unknown]: {\n    editable: false,\n    expandable: false,\n  },\n};\n\nexport const createShallowSerializedDescriptor = (propData: TerminalType): Descriptor => {\n  const { type } = propData;\n\n  const shallowSerializedDescriptor: Descriptor = {\n    type,\n    expandable: shallowPropTypeToTreeMetaData[type].expandable,\n    editable: shallowPropTypeToTreeMetaData[type].editable,\n    preview: typeToDescriptorPreview[propData.type](propData.prop),\n  };\n\n  if (propData.prop !== undefined && serializable[type]) {\n    shallowSerializedDescriptor.value = propData.prop;\n  }\n\n  return shallowSerializedDescriptor;\n};\n\nexport const createLevelSerializedDescriptor = (\n  propData: CompositeType,\n  levelOptions: LevelOptions,\n  continuation: any\n): Descriptor => {\n  const { type, prop } = propData;\n\n  const levelSerializedDescriptor: Descriptor = {\n    type,\n    editable: false,\n    expandable: Object.keys(prop).length > 0,\n    preview: typeToDescriptorPreview[propData.type](propData.prop),\n  };\n\n  if (levelOptions.level !== undefined && levelOptions.currentLevel < levelOptions.level) {\n    const value = getLevelDescriptorValue(propData, levelOptions, continuation);\n    if (value !== undefined) {\n      levelSerializedDescriptor.value = value;\n    }\n  }\n\n  return levelSerializedDescriptor;\n};\n\nexport const createNestedSerializedDescriptor = (\n  propData: CompositeType,\n  levelOptions: LevelOptions,\n  nodes: NestedProp[],\n  nestedSerializer: any\n): Descriptor => {\n  const { type, prop } = propData;\n\n  const nestedSerializedDescriptor: Descriptor = {\n    type,\n    editable: false,\n    expandable: Object.keys(prop).length > 0,\n    preview: typeToDescriptorPreview[propData.type](propData.prop),\n  };\n\n  if (nodes && nodes.length) {\n    const value = getNestedDescriptorValue(propData, levelOptions, nodes, nestedSerializer);\n    if (value !== undefined) {\n      nestedSerializedDescriptor.value = value;\n    }\n  }\n  return nestedSerializedDescriptor;\n};\n\nconst getNestedDescriptorValue = (\n  propData: CompositeType,\n  levelOptions: LevelOptions,\n  nodes: NestedProp[],\n  nestedSerializer: any\n) => {\n  const { type, prop } = propData;\n  const { currentLevel } = levelOptions;\n\n  switch (type) {\n    case PropType.Array:\n      return nodes.map(nestedProp => nestedSerializer(prop[nestedProp.name], nestedProp.children, currentLevel + 1));\n    case PropType.Object:\n      return nodes.reduce((accumulator, nestedProp) => {\n        if (\n          prop.hasOwnProperty(nestedProp.name) &&\n          typeof nestedProp.name === 'string' &&\n          !ignoreList.has(nestedProp.name)\n        ) {\n          accumulator[nestedProp.name] = nestedSerializer(prop[nestedProp.name], nestedProp.children, currentLevel + 1);\n        }\n        return accumulator;\n      }, {});\n  }\n};\n\nconst getLevelDescriptorValue = (propData: CompositeType, levelOptions: LevelOptions, continuation: any) => {\n  const { type, prop } = propData;\n  const { currentLevel, level } = levelOptions;\n\n  switch (type) {\n    case PropType.Array:\n      return prop.map((nested: any, idx: number) => continuation(nested, idx, currentLevel + 1, level));\n    case PropType.Object:\n      return Object.keys(prop).reduce((accumulator, propName) => {\n        if (typeof propName === 'string' && !ignoreList.has(propName)) {\n          accumulator[propName] = continuation(prop[propName], propName, currentLevel + 1, level);\n        }\n        return accumulator;\n      }, {});\n  }\n};\n\nconst truncate = (str: string, max = 20): string => {\n  if (str.length > max) {\n    return str.substr(0, max) + '...';\n  }\n  return str;\n};\n","import { Descriptor, NestedProp, PropType } from 'protocol';\nimport {\n  createLevelSerializedDescriptor,\n  createNestedSerializedDescriptor,\n  createShallowSerializedDescriptor,\n  PropertyData,\n} from './serialized-descriptor-factory';\nimport { METADATA_PROPERTY_NAME } from '../lview-transform';\n\nconst ignoreList = new Set([METADATA_PROPERTY_NAME, '__ngSimpleChanges__']);\n\nconst commonTypes = {\n  boolean: PropType.Boolean,\n  bigint: PropType.BigInt,\n  function: PropType.Function,\n  number: PropType.Number,\n  string: PropType.String,\n  symbol: PropType.Symbol,\n};\n\nconst MAX_LEVEL = 1;\n\nconst getPropType = (prop: any): PropType => {\n  if (prop === undefined) {\n    return PropType.Undefined;\n  }\n  if (prop === null) {\n    return PropType.Null;\n  }\n  if (prop instanceof HTMLElement) {\n    return PropType.HTMLNode;\n  }\n  const type = typeof prop;\n  if (commonTypes[type] !== undefined) {\n    return commonTypes[type];\n  }\n  if (type === 'object') {\n    if (Array.isArray(prop)) {\n      return PropType.Array;\n    } else if (Object.prototype.toString.call(prop) === '[object Date]') {\n      return PropType.Date;\n    } else if (prop instanceof Node) {\n      return PropType.HTMLNode;\n    } else {\n      return PropType.Object;\n    }\n  }\n  return PropType.Unknown;\n};\n\nexport const nestedSerializer = (\n  serializableInstance: any,\n  nodes: NestedProp[],\n  currentLevel = 0,\n  level = MAX_LEVEL\n): Descriptor => {\n  const propData: PropertyData = { prop: serializableInstance, type: getPropType(serializableInstance) };\n  const levelOptions = { level, currentLevel };\n\n  if (currentLevel < level) {\n    return levelSerializer(\n      serializableInstance,\n      undefined,\n      currentLevel,\n      level,\n      nestedSerializerContinuation(nodes, level)\n    );\n  }\n\n  switch (propData.type) {\n    case PropType.Array:\n    case PropType.Object:\n      return createNestedSerializedDescriptor(propData, levelOptions, nodes, nestedSerializer);\n    default:\n      return createShallowSerializedDescriptor(propData);\n  }\n};\n\nconst nestedSerializerContinuation = (nodes: NestedProp[], level: number) => (\n  nestedProp: any,\n  propName: string | number | undefined,\n  nestedLevel: number\n) => {\n  const idx = nodes.findIndex(v => v.name === propName);\n  if (idx < 0) {\n    // The property is not specified in the query.\n    return nestedSerializer(nestedProp, [], nestedLevel, level);\n  }\n  return nestedSerializer(nestedProp, nodes[idx].children, nestedLevel, level);\n};\n\nexport const levelSerializer = (\n  serializableInstance: any,\n  _: string | number | undefined = undefined,\n  currentLevel = 0,\n  level = MAX_LEVEL,\n  continuation = levelSerializer\n): Descriptor => {\n  const propData: PropertyData = { prop: serializableInstance, type: getPropType(serializableInstance) };\n  const levelOptions = { level, currentLevel };\n\n  switch (propData.type) {\n    case PropType.Array:\n    case PropType.Object:\n      return createLevelSerializedDescriptor(propData, levelOptions, continuation);\n    default:\n      return createShallowSerializedDescriptor(propData);\n  }\n};\n\nexport const serializeDirectiveState = (instance: object, levels = MAX_LEVEL): { [key: string]: Descriptor } => {\n  const result = {};\n  for (const prop in instance) {\n    if (instance.hasOwnProperty(prop) && !ignoreList.has(prop)) {\n      result[prop] = levelSerializer(instance[prop], null, 0, levels);\n    }\n  }\n  return result;\n};\n\nexport const deeplySerializeSelectedProperties = (\n  instance: any,\n  props: NestedProp[]\n): { [name: string]: Descriptor } => {\n  const result = {};\n  Object.keys(instance).forEach(propName => {\n    if (ignoreList.has(propName)) {\n      return;\n    }\n    const idx = props.findIndex(v => v.name === propName);\n    if (idx < 0) {\n      result[propName] = levelSerializer(instance[propName]);\n    } else {\n      result[propName] = nestedSerializer(instance[propName], props[idx].children);\n    }\n  });\n  return result;\n};\n","import { deeplySerializeSelectedProperties, serializeDirectiveState } from './state-serializer/state-serializer';\n\nimport {\n  ComponentExplorerViewQuery,\n  DevToolsNode,\n  DirectiveMetadata,\n  DirectivesProperties,\n  ElementPosition,\n  PropertyQueryTypes,\n  UpdatedStateData,\n} from 'protocol';\nimport { buildDirectiveTree, getLViewFromDirectiveOrElementInstance } from './lview-transform';\n\nconst ngDebug = () => (window as any).ng;\n\nexport interface DirectiveInstanceType {\n  instance: any;\n  name: string;\n}\n\nexport interface ComponentInstanceType {\n  instance: any;\n  name: string;\n  isElement: boolean;\n}\n\nexport interface ComponentTreeNode extends DevToolsNode<DirectiveInstanceType, ComponentInstanceType> {\n  children: ComponentTreeNode[];\n}\n\nexport const getLatestComponentState = (\n  query: ComponentExplorerViewQuery,\n  directiveForest?: ComponentTreeNode[]\n): DirectivesProperties | undefined => {\n  // if a directive forest is passed in we don't have to build the forest again.\n  directiveForest = directiveForest ?? buildDirectiveForest();\n\n  const node = queryDirectiveForest(query.selectedElement, directiveForest);\n  if (!node) {\n    return;\n  }\n\n  const result: DirectivesProperties = {};\n\n  const populateResultSet = (dir: DirectiveInstanceType | ComponentInstanceType) => {\n    if (query.propertyQuery.type === PropertyQueryTypes.All) {\n      result[dir.name] = {\n        props: serializeDirectiveState(dir.instance),\n        metadata: getDirectiveMetadata(dir.instance),\n      };\n    }\n    if (query.propertyQuery.type === PropertyQueryTypes.Specified) {\n      result[dir.name] = {\n        props: deeplySerializeSelectedProperties(dir.instance, query.propertyQuery.properties[dir.name] || []),\n        metadata: getDirectiveMetadata(dir.instance),\n      };\n    }\n  };\n\n  node.directives.forEach(populateResultSet);\n  if (node.component) {\n    populateResultSet(node.component);\n  }\n\n  return result;\n};\n\nconst enum DirectiveMetadataKey {\n  INPUTS = 'inputs',\n  OUTPUTS = 'outputs',\n  ENCAPSULATION = 'encapsulation',\n  ON_PUSH = 'onPush',\n}\n\nexport const getDirectiveMetadata = (dir: any): DirectiveMetadata => {\n  const safelyGrabMetadata = (key: DirectiveMetadataKey) => {\n    try {\n      return dir.constructor.ɵcmp ? dir.constructor.ɵcmp[key] : dir.constructor.ɵdir[key];\n    } catch {\n      console.warn(`Could not find metadata for key: ${key} in directive:`, dir);\n      return undefined;\n    }\n  };\n\n  return {\n    inputs: safelyGrabMetadata(DirectiveMetadataKey.INPUTS),\n    outputs: safelyGrabMetadata(DirectiveMetadataKey.OUTPUTS),\n    encapsulation: safelyGrabMetadata(DirectiveMetadataKey.ENCAPSULATION),\n    onPush: safelyGrabMetadata(DirectiveMetadataKey.ON_PUSH),\n  };\n};\n\nconst getRootLViewsHelper = (element: Element, rootLViews = new Set<any>()): Set<any> => {\n  if (!(element instanceof HTMLElement)) {\n    return rootLViews;\n  }\n  const lView = getLViewFromDirectiveOrElementInstance(element);\n  if (lView) {\n    rootLViews.add(lView);\n    return rootLViews;\n  }\n  // tslint:disable-next-line: prefer-for-of\n  for (let i = 0; i < element.children.length; i++) {\n    getRootLViewsHelper(element.children[i], rootLViews);\n  }\n  return rootLViews;\n};\n\n// To get all roots, we first get all elements with ng-version attribute.\n// This includes all app roots plus Angular Elements.\n// We may also have overlays which are on the same level as the top-level\n// app. We get these by traversing the DOM starting from the root DOM\n// element and stopping once we hit a node which is not HTMLElement or\n// has lView data associated with it.\nconst getRootLViews = (element: Element): Set<any> => {\n  const roots = element.querySelectorAll('[ng-version]');\n  return getRootLViewsHelper(element, new Set(Array.from(roots).map(getLViewFromDirectiveOrElementInstance)));\n};\n\nexport const buildDirectiveForest = (): ComponentTreeNode[] => {\n  const roots = getRootLViews(document.documentElement);\n  return Array.prototype.concat.apply([], [...roots].map(buildDirectiveTree));\n};\n\n// Based on an ElementID we return a specific component node.\n// If we can't find any, we return null.\nexport const queryDirectiveForest = (\n  position: ElementPosition,\n  forest: ComponentTreeNode[]\n): ComponentTreeNode | null => {\n  if (!position.length) {\n    return null;\n  }\n  let node: null | ComponentTreeNode = null;\n  for (const i of position) {\n    node = forest[i];\n    if (!node) {\n      return null;\n    }\n    forest = node.children;\n  }\n  return node;\n};\n\nexport const findNodeInForest = (position: ElementPosition, forest: ComponentTreeNode[]): HTMLElement | null => {\n  const foundComponent: ComponentTreeNode | null = queryDirectiveForest(position, forest);\n  return foundComponent ? (foundComponent.nativeElement as HTMLElement) : null;\n};\n\nexport const findNodeFromSerializedPosition = (serializedPosition: string): ComponentTreeNode | null => {\n  const position: number[] = serializedPosition.split(',').map((index) => parseInt(index, 10));\n  return queryDirectiveForest(position, buildDirectiveForest());\n};\n\nexport const updateState = (updatedStateData: UpdatedStateData): void => {\n  const ngd = ngDebug();\n  const node = queryDirectiveForest(updatedStateData.directiveId.element, buildDirectiveForest());\n  if (!node) {\n    console.warn('Could not update the state of component', updatedStateData, 'because the component was not found');\n    return;\n  }\n  if (updatedStateData.directiveId.directive !== undefined) {\n    const directive = node.directives[updatedStateData.directiveId.directive].instance;\n    mutateComponentOrDirective(updatedStateData, directive);\n    ngd.applyChanges(ngd.getOwningComponent(directive));\n    return;\n  }\n  if (node.component) {\n    const comp = node.component.instance;\n    mutateComponentOrDirective(updatedStateData, comp);\n    ngd.applyChanges(comp);\n    return;\n  }\n};\n\nconst mutateComponentOrDirective = (updatedStateData: UpdatedStateData, compOrDirective: any) => {\n  const valueKey = updatedStateData.keyPath.pop();\n  if (valueKey === undefined) {\n    return;\n  }\n\n  let parentObjectOfValueToUpdate = compOrDirective;\n  updatedStateData.keyPath.forEach((key) => {\n    parentObjectOfValueToUpdate = parentObjectOfValueToUpdate[key];\n  });\n\n  parentObjectOfValueToUpdate[valueKey] = updatedStateData.newValue;\n};\n","import { Route } from 'protocol';\nimport { Router, Routes, Route as AngularRoute } from '@angular/router';\n\nexport function parseRoutes(router: Router): Route {\n  const rootName = (router as any).rootComponentType?.name || 'no-name';\n  const rootChildren = router.config;\n\n  const root: Route = {\n    handler: rootName,\n    name: rootName,\n    path: '/',\n    children: rootChildren ? assignChildrenToParent(null, rootChildren) : [],\n    isAux: false,\n    specificity: null,\n    data: null,\n    hash: null,\n  };\n\n  return root;\n}\n\nfunction assignChildrenToParent(parentPath: string | null, children: Routes): Route[] {\n  return children.map((child: AngularRoute) => {\n    const childName = childRouteName(child);\n    const childDescendents: [any] = (child as any)._loadedConfig?.routes || child.children;\n\n    // only found in aux routes, otherwise property will be undefined\n    const isAuxRoute = !!child.outlet;\n\n    const pathFragment = child.outlet ? `(${child.outlet}:${child.path})` : child.path;\n\n    const routeConfig: Route = {\n      handler: childName,\n      data: [],\n      hash: null,\n      specificity: null,\n      name: childName,\n      path: `${parentPath ? parentPath : ''}/${pathFragment}`.split('//').join('/'),\n      isAux: isAuxRoute,\n      children: [],\n    };\n\n    if (childDescendents) {\n      routeConfig.children = assignChildrenToParent(routeConfig.path, childDescendents);\n    }\n\n    if (child.data) {\n      for (const el in child.data) {\n        if (child.data.hasOwnProperty(el)) {\n          routeConfig.data.push({\n            key: el,\n            value: child.data[el],\n          });\n        }\n      }\n    }\n\n    return routeConfig;\n  });\n}\n\nfunction childRouteName(child: AngularRoute): string {\n  if (child.component) {\n    return child.component.name;\n  } else if (child.loadChildren) {\n    return `${child.path} [Lazy]`;\n  } else if (child.redirectTo) {\n    return `${child.path} -> redirecting to -> \"${child.redirectTo}\"`;\n  } else {\n    return 'no-name-route';\n  }\n}\n","import { ComponentTreeNode } from './../component-tree';\nimport { ElementPosition, DevToolsNode } from 'protocol';\nimport { buildDirectiveForest, DirectiveInstanceType, ComponentInstanceType } from '../component-tree';\nimport { Type } from '@angular/core';\n\ninterface TreeNode {\n  parent: TreeNode;\n  directive?: Type<any>;\n  children: TreeNode[];\n}\n\ntype NodeArray = {\n  directive: any;\n  isComponent: boolean;\n}[];\n\nexport class IdentityTracker {\n  private _directiveIdCounter = 0;\n  private _currentDirectivePosition = new Map<any, ElementPosition>();\n  private _currentDirectiveId = new Map<any, number>();\n  private _isComponent = new Map<any, boolean>();\n\n  getDirectivePosition(dir: any): ElementPosition | undefined {\n    return this._currentDirectivePosition.get(dir);\n  }\n\n  getDirectiveId(dir: any): number | undefined {\n    return this._currentDirectiveId.get(dir);\n  }\n\n  hasDirective(dir: any): boolean {\n    return this._currentDirectiveId.has(dir);\n  }\n\n  index(): {\n    newNodes: NodeArray;\n    removedNodes: NodeArray;\n    indexedForest: IndexedNode[];\n    directiveForest: ComponentTreeNode[];\n  } {\n    const directiveForest = buildDirectiveForest();\n    const indexedForest = indexForest(directiveForest);\n    const newNodes: NodeArray = [];\n    const removedNodes: NodeArray = [];\n    const allNodes = new Set<any>();\n    indexedForest.forEach((root) => this._index(root, null, newNodes, allNodes));\n    this._currentDirectiveId.forEach((_: number, dir: any) => {\n      if (!allNodes.has(dir)) {\n        removedNodes.push({ directive: dir, isComponent: !!this._isComponent.get(dir) });\n        // We can't clean these up because during profiling\n        // they might be requested for removed components\n        // this._currentDirectiveId.delete(dir);\n        // this._currentDirectivePosition.delete(dir);\n      }\n    });\n    return { newNodes, removedNodes, indexedForest, directiveForest };\n  }\n\n  private _index(\n    node: IndexedNode,\n    parent: TreeNode | null,\n    newNodes: { directive: any; isComponent: boolean }[],\n    allNodes: Set<any>\n  ): void {\n    if (node.component) {\n      allNodes.add(node.component.instance);\n      this._isComponent.set(node.component.instance, true);\n      this._indexNode(node.component.instance, node.position, newNodes);\n    }\n    (node.directives || []).forEach((dir) => {\n      allNodes.add(dir.instance);\n      this._isComponent.set(dir.instance, false);\n      this._indexNode(dir.instance, node.position, newNodes);\n    });\n    node.children.forEach((child) => this._index(child, parent, newNodes, allNodes));\n  }\n\n  private _indexNode(directive: any, position: ElementPosition, newNodes: NodeArray): void {\n    this._currentDirectivePosition.set(directive, position);\n    if (!this._currentDirectiveId.has(directive)) {\n      newNodes.push({ directive, isComponent: !!this._isComponent.get(directive) });\n      this._currentDirectiveId.set(directive, this._directiveIdCounter++);\n    }\n  }\n\n  destroy(): void {\n    this._currentDirectivePosition = new Map<any, ElementPosition>();\n    this._currentDirectiveId = new Map<any, number>();\n  }\n}\n\nexport interface IndexedNode extends DevToolsNode<DirectiveInstanceType, ComponentInstanceType> {\n  position: ElementPosition;\n  children: IndexedNode[];\n}\n\nconst indexTree = <T extends DevToolsNode<DirectiveInstanceType, ComponentInstanceType>>(\n  node: T,\n  idx: number,\n  parentPosition: number[] = []\n): IndexedNode => {\n  const position = parentPosition.concat([idx]);\n  return {\n    position,\n    element: node.element,\n    component: node.component,\n    directives: node.directives.map((d) => ({ position, ...d })),\n    children: node.children.map((n, i) => indexTree(n, i, position)),\n    nativeElement: node.nativeElement,\n  } as IndexedNode;\n};\n\nexport const indexForest = <T extends DevToolsNode<DirectiveInstanceType, ComponentInstanceType>>(\n  forest: T[]\n): IndexedNode[] => forest.map((n, i) => indexTree(n, i));\n","import { getDirectiveName } from '../highlighter';\nimport { DirectiveForestHooks } from './hooks';\nimport { LifecycleProfile } from 'protocol';\n\nconst markName = (s: string, method: Method) => `🅰️ ${s}#${method}`;\n\nconst supportsPerformance = globalThis.performance && typeof globalThis.performance.getEntriesByName === 'function';\n\ntype Method = keyof LifecycleProfile | 'changeDetection';\n\nconst recordMark = (s: string, method: Method) => {\n  if (supportsPerformance) {\n    performance.mark(`${markName(s, method)}_start`);\n  }\n};\n\nconst endMark = (nodeName: string, method: Method) => {\n  if (supportsPerformance) {\n    const name = markName(nodeName, method);\n    const start = `${name}_start`;\n    const end = `${name}_end`;\n    if (performance.getEntriesByName(start).length > 0) {\n      performance.mark(end);\n      performance.measure(name, start, end);\n    }\n    performance.clearMarks(start);\n    performance.clearMarks(end);\n    performance.clearMeasures(name);\n  }\n};\n\nlet timingAPIFlag = false;\n\nexport const enableTimingAPI = () => (timingAPIFlag = true);\nexport const disableTimingAPI = () => (timingAPIFlag = false);\n\nconst timingAPIEnabled = () => timingAPIFlag;\n\nexport let directiveForestHooks: DirectiveForestHooks;\nexport const initializeOrGetDirectiveForestHooks = () => {\n  if (directiveForestHooks) {\n    return directiveForestHooks;\n  }\n  directiveForestHooks = new DirectiveForestHooks({\n    onChangeDetectionStart(component: any): void {\n      if (!timingAPIEnabled()) {\n        return;\n      }\n      recordMark(getDirectiveName(component), 'changeDetection');\n    },\n    onChangeDetectionEnd(component: any): void {\n      if (!timingAPIEnabled()) {\n        return;\n      }\n      endMark(getDirectiveName(component), 'changeDetection');\n    },\n    onLifecycleHookStart(component: any, lifecyle: keyof LifecycleProfile): void {\n      if (!timingAPIEnabled()) {\n        return;\n      }\n      recordMark(getDirectiveName(component), lifecyle);\n    },\n    onLifecycleHookEnd(component: any, lifecyle: keyof LifecycleProfile): void {\n      if (!timingAPIEnabled()) {\n        return;\n      }\n      endMark(getDirectiveName(component), lifecyle);\n    },\n  });\n  directiveForestHooks.initialize();\n  return directiveForestHooks;\n};\n","import { DirectiveForestHooks, Hooks } from './hooks';\nimport { ElementPosition, ProfilerFrame, ElementProfile, DirectiveProfile, LifecycleProfile } from 'protocol';\nimport { runOutsideAngular, isCustomElement } from '../utils';\nimport { getDirectiveName } from '../highlighter';\nimport { ComponentTreeNode } from '../component-tree';\nimport { initializeOrGetDirectiveForestHooks } from '.';\n\nlet inProgress = false;\nlet inChangeDetection = false;\nlet eventMap: Map<any, DirectiveProfile>;\nlet frameDuration = 0;\nlet hooks: Partial<Hooks> = {};\n\nexport const start = (onFrame: (frame: ProfilerFrame) => void): void => {\n  if (inProgress) {\n    throw new Error('Recording already in progress');\n  }\n  eventMap = new Map<any, DirectiveProfile>();\n  inProgress = true;\n  hooks = getHooks(onFrame);\n  initializeOrGetDirectiveForestHooks().subscribe(hooks);\n};\n\nexport const stop = (): ProfilerFrame => {\n  const directiveForestHooks = initializeOrGetDirectiveForestHooks();\n  const result = flushBuffer(directiveForestHooks);\n  initializeOrGetDirectiveForestHooks().unsubscribe(hooks);\n  hooks = {};\n  inProgress = false;\n  return result;\n};\n\nconst startEvent = (map: { [key: string]: number }, directive: any, label: string) => {\n  const name = getDirectiveName(directive);\n  const key = `${name}#${label}`;\n  map[key] = performance.now();\n};\n\nconst getEventStart = (map: { [key: string]: number }, directive: any, label: string) => {\n  const name = getDirectiveName(directive);\n  const key = `${name}#${label}`;\n  return map[key];\n};\n\nconst getHooks = (onFrame: (frame: ProfilerFrame) => void) => {\n  const timeStartMap: { [key: string]: number } = {};\n  return {\n    // We flush here because it's possible the current node to overwrite\n    // an existing removed node.\n    onCreate(directive: any, node: Node, _: number, isComponent: boolean, position: ElementPosition): void {\n      eventMap.set(directive, {\n        isElement: isCustomElement(node),\n        name: getDirectiveName(directive),\n        isComponent,\n        lifecycle: {},\n      });\n    },\n    onChangeDetectionStart(component: any, node: Node): void {\n      startEvent(timeStartMap, component, 'changeDetection');\n      if (!inChangeDetection) {\n        inChangeDetection = true;\n        const source = getChangeDetectionSource();\n        runOutsideAngular(() => {\n          Promise.resolve().then(() => {\n            inChangeDetection = false;\n            onFrame(flushBuffer(initializeOrGetDirectiveForestHooks(), source));\n          });\n        });\n      }\n      if (!eventMap.has(component)) {\n        eventMap.set(component, {\n          isElement: isCustomElement(node),\n          name: getDirectiveName(component),\n          isComponent: true,\n          changeDetection: 0,\n          lifecycle: {},\n        });\n      }\n    },\n    onChangeDetectionEnd(component: any): void {\n      const profile = eventMap.get(component);\n      if (profile) {\n        let current = profile.changeDetection;\n        if (current === undefined) {\n          current = 0;\n        }\n        const startTimestamp = getEventStart(timeStartMap, component, 'changeDetection');\n        if (startTimestamp === undefined) {\n          return;\n        }\n        const duration = performance.now() - startTimestamp;\n        profile.changeDetection = current + duration;\n        frameDuration += duration;\n      } else {\n        console.warn('Could not find profile for', component);\n      }\n    },\n    onDestroy(directive: any, node: Node, _: number, isComponent: boolean, __: ElementPosition): void {\n      // Make sure we reflect such directives in the report.\n      if (!eventMap.has(directive)) {\n        eventMap.set(directive, {\n          isElement: isComponent && isCustomElement(node),\n          name: getDirectiveName(directive),\n          isComponent,\n          lifecycle: {},\n        });\n      }\n    },\n    onLifecycleHookStart(\n      directive: any,\n      hookName: keyof LifecycleProfile,\n      node: Node,\n      __: number,\n      isComponent: boolean\n    ): void {\n      startEvent(timeStartMap, directive, hookName);\n      if (!eventMap.has(directive)) {\n        eventMap.set(directive, {\n          isElement: isCustomElement(node),\n          name: getDirectiveName(directive),\n          isComponent,\n          lifecycle: {},\n        });\n      }\n    },\n    onLifecycleHookEnd(directive: any, hookName: keyof LifecycleProfile, _: Node, __: number, ___: boolean): void {\n      const dir = eventMap.get(directive);\n      const startTimestamp = getEventStart(timeStartMap, directive, hookName);\n      if (startTimestamp === undefined) {\n        return;\n      }\n      if (!dir) {\n        console.warn('Could not find directive in onLifecycleHook callback', directive, hookName);\n        return;\n      }\n      const duration = performance.now() - startTimestamp;\n      dir.lifecycle[hookName] = (dir.lifecycle[hookName] || 0) + duration;\n      frameDuration += duration;\n    },\n  };\n};\n\nconst insertOrMerge = (lastFrame: ElementProfile, profile: DirectiveProfile) => {\n  let exists = false;\n  lastFrame.directives.forEach((d) => {\n    if (d.name === profile.name) {\n      exists = true;\n      let current = d.changeDetection;\n      if (current === undefined) {\n        current = 0;\n      }\n      d.changeDetection = current + (profile.changeDetection ?? 0);\n      for (const key of Object.keys(profile.lifecycle)) {\n        if (!d.lifecycle[key]) {\n          d.lifecycle[key] = 0;\n        }\n        d.lifecycle[key] += profile.lifecycle[key];\n      }\n    }\n  });\n  if (!exists) {\n    lastFrame.directives.push(profile);\n  }\n};\n\nconst insertElementProfile = (frames: ElementProfile[], position: ElementPosition, profile?: DirectiveProfile) => {\n  if (!profile) {\n    return;\n  }\n  const original = frames;\n  for (let i = 0; i < position.length - 1; i++) {\n    const pos = position[i];\n    if (!frames[pos]) {\n      // TODO(mgechev): consider how to ensure we don't hit this case\n      console.warn('Unable to find parent node for', profile, original);\n      return;\n    }\n    frames = frames[pos].children;\n  }\n  const lastIdx = position[position.length - 1];\n  let lastFrame: ElementProfile = {\n    children: [],\n    directives: [],\n  };\n  if (frames[lastIdx]) {\n    lastFrame = frames[lastIdx];\n  } else {\n    frames[lastIdx] = lastFrame;\n  }\n  insertOrMerge(lastFrame, profile);\n};\n\nconst prepareInitialFrame = (source: string, duration: number) => {\n  const frame: ProfilerFrame = {\n    source,\n    duration,\n    directives: [],\n  };\n  const directiveForestHooks = initializeOrGetDirectiveForestHooks();\n  const directiveForest = directiveForestHooks.getIndexedDirectiveForest();\n  const traverse = (node: ComponentTreeNode, children = frame.directives) => {\n    let position: ElementPosition | undefined;\n    if (node.component) {\n      position = directiveForestHooks.getDirectivePosition(node.component.instance);\n    } else {\n      position = directiveForestHooks.getDirectivePosition(node.directives[0].instance);\n    }\n    if (position === undefined) {\n      return;\n    }\n    const directives = node.directives.map((d) => {\n      return {\n        isComponent: false,\n        isElement: false,\n        name: getDirectiveName(d.instance),\n        lifecycle: {},\n      };\n    });\n    if (node.component) {\n      directives.push({\n        isElement: node.component.isElement,\n        isComponent: true,\n        lifecycle: {},\n        name: getDirectiveName(node.component.instance),\n      });\n    }\n    const result = {\n      children: [],\n      directives,\n    };\n    children[position[position.length - 1]] = result;\n    node.children.forEach((n) => traverse(n, result.children));\n  };\n  directiveForest.forEach((n) => traverse(n));\n  return frame;\n};\n\nconst flushBuffer = (directiveForestHooks: DirectiveForestHooks, source: string = '') => {\n  const items = Array.from(eventMap.keys());\n  const positions: ElementPosition[] = [];\n  const positionDirective = new Map<ElementPosition, any>();\n  items.forEach((dir) => {\n    const position = directiveForestHooks.getDirectivePosition(dir);\n    if (position === undefined) {\n      return;\n    }\n    positions.push(position);\n    positionDirective.set(position, dir);\n  });\n  positions.sort(lexicographicOrder);\n\n  const result = prepareInitialFrame(source, frameDuration);\n  frameDuration = 0;\n\n  positions.forEach((position) => {\n    const dir = positionDirective.get(position);\n    insertElementProfile(result.directives, position, eventMap.get(dir));\n  });\n  eventMap = new Map<any, DirectiveProfile>();\n  return result;\n};\n\nconst getChangeDetectionSource = () => {\n  const zone = (window as any).Zone;\n  if (!zone || !zone.currentTask) {\n    return '';\n  }\n  return zone.currentTask.source;\n};\n\nconst lexicographicOrder = (a: ElementPosition, b: ElementPosition) => {\n  if (a.length < b.length) {\n    return -1;\n  }\n  if (a.length > b.length) {\n    return 1;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] < b[i]) {\n      return -1;\n    }\n    if (a[i] > b[i]) {\n      return 1;\n    }\n  }\n  return 0;\n};\n","import { ComponentTreeNode } from './../component-tree';\nimport { ElementPosition, LifecycleProfile } from 'protocol';\nimport { componentMetadata, runOutsideAngular } from '../utils';\nimport { IdentityTracker, IndexedNode } from './identity-tracker';\nimport {\n  getLViewFromDirectiveOrElementInstance,\n  getDirectiveHostElement,\n  METADATA_PROPERTY_NAME,\n} from '../lview-transform';\nimport { Subject } from 'rxjs';\n\nexport type CreationHook = (\n  componentOrDirective: any,\n  node: Node,\n  id: number,\n  isComponent: boolean,\n  position: ElementPosition\n) => void;\n\nexport type LifecycleStartHook = (\n  componentOrDirective: any,\n  hook: keyof LifecycleProfile | 'unknown',\n  node: Node,\n  id: number,\n  isComponent: boolean\n) => void;\n\nexport type LifecycleEndHook = (\n  componentOrDirective: any,\n  hook: keyof LifecycleProfile | 'unknown',\n  node: Node,\n  id: number,\n  isComponent: boolean\n) => void;\n\nexport type ChangeDetectionStartHook = (component: any, node: Node, id: number, position: ElementPosition) => void;\n\nexport type ChangeDetectionEndHook = (component: any, node: Node, id: number, position: ElementPosition) => void;\n\nexport type DestroyHook = (\n  componentOrDirective: any,\n  node: Node,\n  id: number,\n  isComponent: boolean,\n  position: ElementPosition\n) => void;\n\nexport interface Hooks {\n  onCreate: CreationHook;\n  onDestroy: DestroyHook;\n  onChangeDetectionStart: ChangeDetectionStartHook;\n  onChangeDetectionEnd: ChangeDetectionEndHook;\n  onLifecycleHookStart: LifecycleStartHook;\n  onLifecycleHookEnd: LifecycleEndHook;\n}\n\nconst hookNames = [\n  'OnInit',\n  'OnDestroy',\n  'OnChanges',\n  'DoCheck',\n  'AfterContentInit',\n  'AfterContentChecked',\n  'AfterViewInit',\n  'AfterViewChecked',\n];\n\nconst hookMethodNames = new Set(hookNames.map((hook) => `ng${hook}`));\n\nconst hookTViewProperties = [\n  'preOrderHooks',\n  'preOrderCheckHooks',\n  'contentHooks',\n  'contentCheckHooks',\n  'viewHooks',\n  'viewCheckHooks',\n  'destroyHooks',\n];\n\nconst getLifeCycleName = (obj: {}, fn: any): keyof LifecycleProfile | 'unknown' => {\n  const proto = Object.getPrototypeOf(obj);\n  const keys = Object.getOwnPropertyNames(proto);\n  for (const propName of keys) {\n    // We don't want to touch random get accessors.\n    if (!hookMethodNames.has(propName)) {\n      continue;\n    }\n    if (proto[propName] === fn) {\n      return propName as keyof LifecycleProfile;\n    }\n  }\n  const fnName = fn.name;\n  if (typeof fnName !== 'string') {\n    return 'unknown';\n  }\n  for (const hookName of hookNames) {\n    if (fnName.indexOf(hookName) >= 0) {\n      return `ng${hookName}` as keyof LifecycleProfile;\n    }\n  }\n  return 'unknown';\n};\n\n/**\n * This is a temporal \"polyfill\" until we receive\n * more comprehensive framework debugging APIs.\n */\nexport class DirectiveForestHooks {\n  private _patched = new Map<any, () => void>();\n  private _undoLifecyclePatch: (() => void)[] = [];\n  private _lastChangeDetection = new Map<any, number>();\n  private _tracker = new IdentityTracker();\n  private _forest: ComponentTreeNode[] = [];\n  private _indexedForest: IndexedNode[] = [];\n  private _inChangeDetection = false;\n  private _changeDetection$ = new Subject<void>();\n\n  private _hooks: Partial<Hooks>[] = [];\n\n  constructor(config: Partial<Hooks>) {\n    this._hooks.push(config);\n  }\n\n  get changeDetection$(): Subject<void> {\n    return this._changeDetection$;\n  }\n\n  getDirectivePosition(dir: any): ElementPosition | undefined {\n    const result = this._tracker.getDirectivePosition(dir);\n    if (result === undefined) {\n      console.warn('Unable to find position of', dir);\n    }\n    return result;\n  }\n\n  getDirectiveId(dir: any): number | undefined {\n    const result = this._tracker.getDirectiveId(dir);\n    if (result === undefined) {\n      console.warn('Unable to find ID of', result);\n    }\n    return result;\n  }\n\n  getIndexedDirectiveForest(): IndexedNode[] {\n    return this._indexedForest;\n  }\n\n  getDirectiveForest(): ComponentTreeNode[] {\n    return this._forest;\n  }\n\n  initialize(): void {\n    this.indexForest();\n  }\n\n  destroy(): void {\n    this._lastChangeDetection = new Map<any, number>();\n    this._tracker.destroy();\n\n    for (const [cmp, template] of this._patched) {\n      const meta = componentMetadata(cmp);\n      meta.template = template;\n      meta.tView.template = template;\n    }\n\n    this._patched = new Map<any, () => void>();\n    this._undoLifecyclePatch.forEach((p) => p());\n    this._undoLifecyclePatch = [];\n  }\n\n  indexForest(): void {\n    const { newNodes, removedNodes, indexedForest, directiveForest } = this._tracker.index();\n    this._indexedForest = indexedForest;\n    this._forest = directiveForest;\n    newNodes.forEach((node) => {\n      this._observeLifecycle(node.directive, node.isComponent);\n      this._observeComponent(node.directive);\n      this._fireCreationCallback(node.directive, node.isComponent);\n    });\n    removedNodes.forEach((node) => {\n      this._patched.delete(node.directive);\n      this._fireDestroyCallback(node.directive, node.isComponent);\n    });\n  }\n\n  subscribe(config: Partial<Hooks>): void {\n    this._hooks.push(config);\n  }\n\n  unsubscribe(config: Partial<Hooks>): void {\n    this._hooks.splice(this._hooks.indexOf(config), 1);\n  }\n\n  private _fireCreationCallback(component: any, isComponent: boolean): void {\n    const position = this._tracker.getDirectivePosition(component);\n    const id = this._tracker.getDirectiveId(component);\n    this._onCreate(component, getDirectiveHostElement(component), id, isComponent, position);\n  }\n\n  private _fireDestroyCallback(component: any, isComponent: boolean): void {\n    const position = this._tracker.getDirectivePosition(component);\n    const id = this._tracker.getDirectiveId(component);\n    this._onDestroy(component, getDirectiveHostElement(component), id, isComponent, position);\n  }\n\n  private _observeComponent(cmp: any): void {\n    const declarations = componentMetadata(cmp);\n    if (!declarations) {\n      return;\n    }\n    const original = declarations.template;\n    const self = this;\n    if (original.patched) {\n      return;\n    }\n    declarations.tView.template = function (_: any, component: any): void {\n      if (!self._inChangeDetection) {\n        self._inChangeDetection = true;\n        runOutsideAngular(() => {\n          Promise.resolve().then(() => {\n            self._changeDetection$.next();\n            self._inChangeDetection = false;\n          });\n        });\n      }\n      const position = self._tracker.getDirectivePosition(component);\n      const start = performance.now();\n      const id = self._tracker.getDirectiveId(component);\n\n      self._onChangeDetectionStart(component, getDirectiveHostElement(component), id, position);\n      original.apply(this, arguments);\n      if (self._tracker.hasDirective(component) && id !== undefined && position !== undefined) {\n        self._onChangeDetectionEnd(component, getDirectiveHostElement(component), id, position);\n      } else {\n        self._lastChangeDetection.set(component, performance.now() - start);\n      }\n    };\n    declarations.tView.template.patched = true;\n    this._patched.set(cmp, original);\n  }\n\n  private _observeLifecycle(directive: any, isComponent: boolean): void {\n    const ctx = getLViewFromDirectiveOrElementInstance(directive);\n    if (!ctx) {\n      return;\n    }\n    const tview = ctx[1];\n    hookTViewProperties.forEach((hook) => {\n      const current = tview[hook];\n      if (!Array.isArray(current)) {\n        return;\n      }\n      current.forEach((el: any, idx: number) => {\n        if (el.patched) {\n          return;\n        }\n        if (typeof el === 'function') {\n          const self = this;\n          current[idx] = function (): any {\n            // We currently don't want to notify the consumer\n            // for execution of lifecycle hooks of services and pipes.\n            // These two abstractions don't have `__ngContext__`, and\n            // currently we won't be able to extract the required\n            // metadata by the UI.\n            if (!this[METADATA_PROPERTY_NAME]) {\n              return;\n            }\n            const id = self._tracker.getDirectiveId(this);\n            const lifecycleHookName = getLifeCycleName(this, el);\n            const element = getDirectiveHostElement(this);\n            self._onLifecycleHookStart(this, lifecycleHookName, element, id, isComponent);\n            const result = el.apply(this, arguments);\n            self._onLifecycleHookEnd(this, lifecycleHookName, element, id, isComponent);\n            return result;\n          };\n          current[idx].patched = true;\n          this._undoLifecyclePatch.push(() => {\n            current[idx] = el;\n          });\n        }\n      });\n    });\n  }\n\n  private _onCreate(\n    _: any,\n    __: Node,\n    id: number | undefined,\n    ___: boolean,\n    position: ElementPosition | undefined\n  ): void {\n    if (id === undefined || position === undefined) {\n      return;\n    }\n    this._invokeCallback('onCreate', arguments);\n  }\n\n  private _onDestroy(\n    _: any,\n    __: Node,\n    id: number | undefined,\n    ___: boolean,\n    position: ElementPosition | undefined\n  ): void {\n    if (id === undefined || position === undefined) {\n      return;\n    }\n    this._invokeCallback('onDestroy', arguments);\n  }\n\n  private _onChangeDetectionStart(\n    _: any,\n    __: Node,\n    id: number | undefined,\n    position: ElementPosition | undefined\n  ): void {\n    if (id === undefined || position === undefined) {\n      return;\n    }\n    this._invokeCallback('onChangeDetectionStart', arguments);\n  }\n\n  private _onChangeDetectionEnd(_: any, __: Node, id: number | undefined, position: ElementPosition | undefined): void {\n    if (id === undefined || position === undefined) {\n      return;\n    }\n    this._invokeCallback('onChangeDetectionEnd', arguments);\n  }\n\n  private _onLifecycleHookStart(\n    _: any,\n    __: keyof LifecycleProfile | 'unknown',\n    ___: Node,\n    id: number | undefined,\n    ____: boolean\n  ): void {\n    if (id === undefined) {\n      return;\n    }\n    this._invokeCallback('onLifecycleHookStart', arguments);\n  }\n\n  private _onLifecycleHookEnd(\n    _: any,\n    __: keyof LifecycleProfile | 'unknown',\n    ___: Node,\n    id: number | undefined,\n    ____: boolean\n  ): void {\n    if (id === undefined) {\n      return;\n    }\n    this._invokeCallback('onLifecycleHookEnd', arguments);\n  }\n\n  private _invokeCallback(name: keyof Hooks, args: IArguments): void {\n    this._hooks.forEach((config) => {\n      const cb = config[name];\n      if (cb) {\n        cb.apply(null, args);\n      }\n    });\n  }\n}\n","import { unHighlight, highlight, findComponentAndHost } from '../highlighter';\nimport { Type } from '@angular/core';\nimport { ComponentTreeNode, findNodeInForest } from '../component-tree';\nimport { ElementPosition } from 'protocol';\nimport { initializeOrGetDirectiveForestHooks } from '../hooks';\n\nexport interface ComponentInspectorOptions {\n  onComponentEnter: (id: number) => void;\n  onComponentSelect: (id: number) => void;\n  onComponentLeave: () => void;\n}\n\nexport class ComponentInspector {\n  private _selectedComponent: { component: Type<unknown>; host: HTMLElement | null };\n  private readonly _onComponentEnter;\n  private readonly _onComponentSelect;\n  private readonly _onComponentLeave;\n\n  constructor(\n    componentOptions: ComponentInspectorOptions = {\n      onComponentEnter: () => {},\n      onComponentLeave: () => {},\n      onComponentSelect: () => {},\n    }\n  ) {\n    this.bindMethods();\n    this._onComponentEnter = componentOptions.onComponentEnter;\n    this._onComponentSelect = componentOptions.onComponentSelect;\n    this._onComponentLeave = componentOptions.onComponentLeave;\n  }\n\n  startInspecting(): void {\n    window.addEventListener('mouseover', this.elementMouseOver, true);\n    window.addEventListener('click', this.elementClick, true);\n    window.addEventListener('mouseout', this.cancelEvent, true);\n  }\n\n  stopInspecting(): void {\n    window.removeEventListener('mouseover', this.elementMouseOver, true);\n    window.removeEventListener('click', this.elementClick, true);\n    window.removeEventListener('mouseout', this.cancelEvent, true);\n  }\n\n  elementClick(e: MouseEvent): void {\n    e.stopImmediatePropagation();\n    e.preventDefault();\n\n    if (this._selectedComponent.component && this._selectedComponent.host) {\n      this._onComponentSelect(initializeOrGetDirectiveForestHooks().getDirectiveId(this._selectedComponent.component));\n    }\n  }\n\n  elementMouseOver(e: MouseEvent): void {\n    this.cancelEvent(e);\n\n    const el = e.target as HTMLElement;\n    if (el) {\n      this._selectedComponent = findComponentAndHost(el);\n    }\n\n    unHighlight();\n    if (this._selectedComponent.component && this._selectedComponent.host) {\n      highlight(this._selectedComponent.host);\n      this._onComponentEnter(initializeOrGetDirectiveForestHooks().getDirectiveId(this._selectedComponent.component));\n    }\n  }\n\n  cancelEvent(e: MouseEvent): void {\n    e.stopImmediatePropagation();\n    e.preventDefault();\n    this._onComponentLeave();\n  }\n\n  bindMethods(): void {\n    this.startInspecting = this.startInspecting.bind(this);\n    this.stopInspecting = this.stopInspecting.bind(this);\n    this.elementMouseOver = this.elementMouseOver.bind(this);\n    this.elementClick = this.elementClick.bind(this);\n    this.cancelEvent = this.cancelEvent.bind(this);\n  }\n\n  highlightByPosition(position: ElementPosition): void {\n    const forest: ComponentTreeNode[] = initializeOrGetDirectiveForestHooks().getDirectiveForest();\n    const elementToHighlight: HTMLElement | null = findNodeInForest(position, forest);\n    if (elementToHighlight) {\n      highlight(elementToHighlight);\n    }\n  }\n}\n","import { arrayEquals } from 'shared-utils';\nimport { ElementPosition } from 'protocol';\nimport { ComponentTreeNode } from './component-tree';\n\ninterface ConsoleReferenceNode {\n  node: ComponentTreeNode | null;\n  position: ElementPosition;\n}\n\nconst CONSOLE_REFERENCE_PREFIX = '$ng';\nconst CAPACITY = 5;\n\nconst nodesForConsoleReference: ConsoleReferenceNode[] = [];\n\nexport const setConsoleReference = (referenceNode: ConsoleReferenceNode) => {\n  if (referenceNode.node === null) {\n    return;\n  }\n  _setConsoleReference(referenceNode);\n};\n\nconst _setConsoleReference = (referenceNode: ConsoleReferenceNode) => {\n  prepareCurrentReferencesForInsertion(referenceNode);\n  nodesForConsoleReference.unshift(referenceNode);\n  assignConsoleReferencesFrom(nodesForConsoleReference);\n};\n\nconst prepareCurrentReferencesForInsertion = (referenceNode: ConsoleReferenceNode) => {\n  const foundIndex = nodesForConsoleReference.findIndex((nodeToLookFor) =>\n    arrayEquals(nodeToLookFor.position, referenceNode.position)\n  );\n  if (foundIndex !== -1) {\n    nodesForConsoleReference.splice(foundIndex, 1);\n  } else if (nodesForConsoleReference.length === CAPACITY) {\n    nodesForConsoleReference.pop();\n  }\n};\n\nconst assignConsoleReferencesFrom = (referenceNodes: ConsoleReferenceNode[]) => {\n  referenceNodes.forEach((referenceNode, index) =>\n    setDirectiveKey(referenceNode.node, getConsoleReferenceWithIndexOf(index))\n  );\n};\n\nconst setDirectiveKey = (node: ComponentTreeNode | null, key: string) => {\n  Object.defineProperty(window, key, {\n    get: () => {\n      if (node?.component) {\n        return node.component.instance;\n      }\n      if (node?.nativeElement) {\n        return node.nativeElement;\n      }\n      return node;\n    },\n    configurable: true,\n  });\n};\n\nconst getConsoleReferenceWithIndexOf = (consoleReferenceIndex: number) =>\n  `${CONSOLE_REFERENCE_PREFIX}${consoleReferenceIndex}`;\n","declare const ng: any;\n\nexport const appIsAngularInDevMode = (): boolean => {\n  return appIsAngular() && appHasGlobalNgDebugObject();\n};\n\nexport const appIsAngularIvy = (): boolean => {\n  return !!(window as any).getAllAngularRootElements?.()?.[0]?.__ngContext__;\n};\n\nexport const appIsAngular = (): boolean => {\n  return !!getAngularVersion();\n};\n\nexport const appIsSupportedAngularVersion = (): boolean => {\n  const version = getAngularVersion();\n  if (!version) {\n    return false;\n  }\n  const major = parseInt(version.toString().split('.')[0], 10);\n  return appIsAngular() && (major >= 9 || major === 0);\n};\n\nconst appHasGlobalNgDebugObject = (): boolean => {\n  return typeof ng !== 'undefined';\n};\n\nexport const getAngularVersion = (): string | null => {\n  const el = document.querySelector('[ng-version]');\n  if (!el) {\n    return null;\n  }\n  return el.getAttribute('ng-version');\n};\n","import {\n  DirectivePosition,\n  ElementPosition,\n  Events,\n  MessageBus,\n  DevToolsNode,\n  DirectiveType,\n  ComponentType,\n  ProfilerFrame,\n  ComponentExplorerViewQuery,\n  Route,\n} from 'protocol';\nimport { ComponentTreeNode, getLatestComponentState, queryDirectiveForest, updateState } from './component-tree';\nimport { parseRoutes } from './router-tree';\nimport { start as startProfiling, stop as stopProfiling } from './hooks/capture';\nimport { serializeDirectiveState } from './state-serializer/state-serializer';\nimport { ComponentInspector } from './component-inspector/component-inspector';\nimport { setConsoleReference } from './set-console-reference';\nimport { unHighlight } from './highlighter';\nimport {\n  getAngularVersion,\n  appIsAngularInDevMode,\n  appIsSupportedAngularVersion,\n  appIsAngularIvy,\n} from './angular-check';\nimport { debounceTime } from 'rxjs/operators';\nimport { disableTimingAPI, enableTimingAPI, initializeOrGetDirectiveForestHooks } from './hooks';\nimport { runOutsideAngular } from './utils';\n\nexport const subscribeToClientEvents = (messageBus: MessageBus<Events>): void => {\n  messageBus.on('shutdown', shutdownCallback(messageBus));\n\n  messageBus.on('getLatestComponentExplorerView', getLatestComponentExplorerViewCallback(messageBus));\n\n  messageBus.on('queryNgAvailability', checkForAngularCallback(messageBus));\n\n  messageBus.on('startProfiling', startProfilingCallback(messageBus));\n  messageBus.on('stopProfiling', stopProfilingCallback(messageBus));\n\n  messageBus.on('setSelectedComponent', selectedComponentCallback);\n\n  messageBus.on('getNestedProperties', getNestedPropertiesCallback(messageBus));\n  messageBus.on('getRoutes', getRoutesCallback(messageBus));\n\n  messageBus.on('updateState', updateState);\n\n  messageBus.on('enableTimingAPI', enableTimingAPI);\n  messageBus.on('disableTimingAPI', disableTimingAPI);\n\n  if (appIsAngularInDevMode() && appIsSupportedAngularVersion() && appIsAngularIvy()) {\n    setupInspector(messageBus);\n    // Often websites have `scroll` event listener which triggers\n    // Angular's change detection. We don't want to constantly send\n    // update requests, instead we want to request an update at most\n    // every 250ms\n    runOutsideAngular(() => {\n      initializeOrGetDirectiveForestHooks()\n        .changeDetection$.pipe(debounceTime(250))\n        .subscribe(() => messageBus.emit('componentTreeDirty'));\n    });\n  }\n};\n\n//\n// Callback Definitions\n//\n\nconst shutdownCallback = (messageBus: MessageBus<Events>) => () => {\n  messageBus.destroy();\n};\n\nconst getLatestComponentExplorerViewCallback = (messageBus: MessageBus<Events>) => (\n  query?: ComponentExplorerViewQuery\n) => {\n  // We want to force re-indexing of the component tree.\n  // Pressing the refresh button means the user saw stuck UI.\n\n  initializeOrGetDirectiveForestHooks().indexForest();\n\n  if (!query) {\n    messageBus.emit('latestComponentExplorerView', [\n      {\n        forest: prepareForestForSerialization(initializeOrGetDirectiveForestHooks().getIndexedDirectiveForest()),\n      },\n    ]);\n    return;\n  }\n  messageBus.emit('latestComponentExplorerView', [\n    {\n      forest: prepareForestForSerialization(initializeOrGetDirectiveForestHooks().getIndexedDirectiveForest()),\n      properties: getLatestComponentState(query, initializeOrGetDirectiveForestHooks().getDirectiveForest()),\n    },\n  ]);\n};\n\nconst checkForAngularCallback = (messageBus: MessageBus<Events>) => () => checkForAngular(messageBus);\nconst getRoutesCallback = (messageBus: MessageBus<Events>) => () => getRoutes(messageBus);\n\nconst startProfilingCallback = (messageBus: MessageBus<Events>) => () =>\n  startProfiling((frame: ProfilerFrame) => {\n    messageBus.emit('sendProfilerChunk', [frame]);\n  });\n\nconst stopProfilingCallback = (messageBus: MessageBus<Events>) => () => {\n  messageBus.emit('profilerResults', [stopProfiling()]);\n};\n\nconst selectedComponentCallback = (position: ElementPosition) => {\n  const node = queryDirectiveForest(position, initializeOrGetDirectiveForestHooks().getIndexedDirectiveForest());\n  setConsoleReference({ node, position });\n};\n\nconst getNestedPropertiesCallback = (messageBus: MessageBus<Events>) => (\n  position: DirectivePosition,\n  propPath: string[]\n) => {\n  const emitEmpty = () => messageBus.emit('nestedProperties', [position, { props: {} }, propPath]);\n  const node = queryDirectiveForest(\n    position.element,\n    initializeOrGetDirectiveForestHooks().getIndexedDirectiveForest()\n  );\n  if (!node) {\n    return emitEmpty();\n  }\n  const current = position.directive === undefined ? node.component : node.directives[position.directive];\n  if (!current) {\n    return emitEmpty();\n  }\n  let data = current.instance;\n  for (const prop of propPath) {\n    data = data[prop];\n    if (!data) {\n      console.error('Cannot access the properties', propPath, 'of', node);\n    }\n  }\n  messageBus.emit('nestedProperties', [position, { props: serializeDirectiveState(data) }, propPath]);\n};\n\n//\n// Subscribe Helpers\n//\nconst getRoutes = (messageBus: MessageBus<Events>) => {\n  const node = queryDirectiveForest([0], initializeOrGetDirectiveForestHooks().getIndexedDirectiveForest());\n  let routes: Route[] = [];\n  if (node?.component?.instance.router) {\n    routes = [parseRoutes(node?.component?.instance.router)];\n  }\n  messageBus.emit('updateRouterTree', [routes]);\n};\n\nconst checkForAngular = (messageBus: MessageBus<Events>): void => {\n  const ngVersion = getAngularVersion();\n  const appIsIvy = appIsAngularIvy();\n  if (!ngVersion) {\n    setTimeout(() => checkForAngular(messageBus), 500);\n    return;\n  }\n  if (appIsIvy) {\n    initializeOrGetDirectiveForestHooks();\n  }\n  messageBus.emit('ngAvailability', [\n    { version: ngVersion.toString(), devMode: appIsAngularInDevMode(), ivy: appIsIvy },\n  ]);\n};\n\nconst setupInspector = (messageBus: MessageBus<Events>) => {\n  const inspector = new ComponentInspector({\n    onComponentEnter: (id: number) => {\n      messageBus.emit('highlightComponent', [id]);\n    },\n    onComponentLeave: () => {\n      messageBus.emit('removeComponentHighlight');\n    },\n    onComponentSelect: (id: number) => {\n      messageBus.emit('selectComponent', [id]);\n    },\n  });\n\n  messageBus.on('inspectorStart', inspector.startInspecting);\n  messageBus.on('inspectorEnd', inspector.stopInspecting);\n\n  messageBus.on('createHighlightOverlay', (position: ElementPosition) => {\n    inspector.highlightByPosition(position);\n  });\n  messageBus.on('removeHighlightOverlay', unHighlight);\n};\n\nexport interface SerializableDirectiveInstanceType extends DirectiveType {\n  id: number;\n}\n\nexport interface SerializableComponentInstanceType extends ComponentType {\n  id: number;\n}\n\nexport interface SerializableComponentTreeNode\n  extends DevToolsNode<SerializableDirectiveInstanceType, SerializableComponentInstanceType> {\n  children: SerializableComponentTreeNode[];\n}\n\n// Here we drop properties to prepare the tree for serialization.\n// We don't need the component instance, so we just traverse the tree\n// and leave the component name.\nexport const prepareForestForSerialization = (roots: ComponentTreeNode[]): SerializableComponentTreeNode[] => {\n  return roots.map((node) => {\n    return {\n      element: node.element,\n      component: node.component\n        ? {\n            name: node.component.name,\n            isElement: node.component.isElement,\n            id: initializeOrGetDirectiveForestHooks().getDirectiveId(node.component.instance),\n          }\n        : null,\n      directives: node.directives.map((d) => ({\n        name: d.name,\n        id: initializeOrGetDirectiveForestHooks().getDirectiveId(d.instance),\n      })),\n      children: prepareForestForSerialization(node.children),\n    } as SerializableComponentTreeNode;\n  });\n};\n","import { MessageBus, Events } from 'protocol';\nimport { subscribeToClientEvents } from './client-event-subscribers';\n\nexport const initializeMessageBus = (messageBus: MessageBus<Events>) => {\n  subscribeToClientEvents(messageBus);\n};\n"]}